package appdynamics

import (
	"os"
	"encoding/json"
	"fmt"
	"strings"
	"io/ioutil"
	"errors"
)

type Plan struct {
	Credentials Credential `json:"credentials"`
}

type Credential struct {
	ControllerHost  string `json:"host-name"`
	ControllerPort  string `json:"port"`
	SslEnabled      bool   `json:"ssl-enabled"`
	AccountAccessKey string `json:"account-access-key"`
	AccountName     string `json:"account-name"`
}

type VcapApplication struct {
	ApplicationName string `json:"application_name"`
	ApplicationId   string `json:"application_id"`
}

func getEnv(key, fallback string) string {
	if value, ok := os.LookupEnv(key); ok {
		return value
	}
	return fallback
}

func GatherAppdynamicsInfo() map[string]string {
	vcapServices := os.Getenv("VCAP_SERVICES")
	vcapApplication := os.Getenv("VCAP_APPLICATION")

	services := make(map[string][]Plan)
	application := VcapApplication{}

	err := json.Unmarshal([]byte(vcapServices), &services)
	if err != nil {
		fmt.Println(err)
	}

	err = json.Unmarshal([]byte(vcapApplication), &application)
	if err != nil {
		fmt.Println(err)
	}

	if val, ok := services["appdynamics"]; ok {
		appdynamicsPlan := val[0].Credentials
		AppdEnvMap := make(map[string]string)

		AppdEnvMap["APPD_APP_NAME"] = getEnv("APPD_APP_NAME", application.ApplicationName)
		AppdEnvMap["APPD_TIER_NAME"] = getEnv("APPD_TIER_NAME", application.ApplicationName)
		AppdEnvMap["APPD_NODE_NAME"] = getEnv("APPD_NODE_NAME", application.ApplicationName)
		AppdEnvMap["APPD_CONTROLLER_HOST"] = appdynamicsPlan.ControllerHost
		AppdEnvMap["APPD_CONTROLLER_PORT"] = appdynamicsPlan.ControllerPort
		AppdEnvMap["APPD_ACCOUNT_ACCESS_KEY"] = appdynamicsPlan.AccountAccessKey
		AppdEnvMap["APPD_ACCOUNT_NAME"] = appdynamicsPlan.AccountName
		AppdEnvMap["APPD_SSL_ENABLED"] = "off"

		return AppdEnvMap

	} else {
		return nil
	}

}

func GenerateAppdynamicsScript(envVars map[string]string) string {

	scriptContents := "# Autogenerated Appdynamics Script \n"

	for envKey, envVal := range envVars {
		envStr := fmt.Sprintf("export %s=%s", envKey, envVal)
		scriptContents += "\n" + envStr
	}

	return scriptContents
}

func GenerateStartUpCommand(startCommand string) (string, error) {
	webCommands := strings.SplitN(startCommand, ":", 2)
	if len(webCommands) != 2 {
		return "", errors.New("improper format found in Procfile")
	}
	return fmt.Sprintf("web: pyagent run -- %s", webCommands[1]), nil
}

func RewriteProcFile(procFilePath string) error {
	startCommand, err := ioutil.ReadFile(procFilePath)
	if err != nil {
		return err
	}
	if newCommand, err :=  GenerateStartUpCommand(string(startCommand)); err != nil {
		return err
	} else {
		if err := ioutil.WriteFile(procFilePath, []byte(newCommand), 0644); err != nil {
			return err
		}
	}
	return nil
}
